package com.byyd.middleware.iface.dao.jpa;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.PluralAttribute;
import javax.persistence.metamodel.SingularAttribute;

import com.adfonic.domain.BusinessKey;
import com.byyd.middleware.iface.dao.FetchStrategyImpl;

/**
 * This class is a JPA device used to specify fields to be eagerly fetched for
 * an entity during a query. Note that as of the time this was written, this
 * mechanism can only be used with the JPA Criteria API. None of the other
 * methods (Named Queries, native queries, ...) expose the objects necessary to
 * use this.
 *
 * This methodology is inspired by this post:
 * http://forum.springsource.org/showthread.php?114485-Spring-Data-JPA-Eager-Fetching
 *
 * It relies on the availability of MetaModel classes generated by the JPA
 * provider. A MetaModel class is an abstract class that lists all attributes
 * resulting from a relationship mapping, separatesd in 2 groups: -
 * SingularAttributes are the fields that map as single instances of a class -
 * PluralAttributes are the fields that map as collections of instances of a
 * class
 *
 * In the case of Hibernate, to trigger the generation of these classes, add the
 * following artifact to your POM:
 *
 * <dependency> <groupId>org.hibernate</groupId>
 * <artifactId>hibernate-jpamodelgen</artifactId> <version>1.1.1.Final</version>
 * <scope>compile</scope> </dependency>
 *
 * That will plug into the "Java Service Provider" interface at compile time (it
 * just gets discovered on the classpath and used)
 *
 * See this for more details:
 * http://docs.jboss.org/hibernate/jpamodelgen/1.1/reference/en-US/html_single/
 *
 * Internally, Fetches instances are created passing a Domain class as generic
 * qualifier. Then, using the MetaModel version of the Domain class used,
 * SingularAttributes and PluralAttributes are added to it, with an optional
 * join type specification. One Attribute is added per field you want eagerly
 * loaded in the instances of the Domain class that will be created when
 * querying. The domain class passed as the generic qualifier must therefore be
 * the class of the intended results of the query. Once all the attributes have
 * been added, the bindFetchAttributes() method must be invoked with the Root
 * object corresponding to the Domain class used in the constructor, and the
 * Fetches instance. This method will "set" each attribute within the Root
 * object, along with a JoinType. These settings is what will drive the SQL
 * generation by the JPA Criteria API to eagerly fetch the desired components at
 * query time.
 *
 * Manual use of Fetches instances like demonstrated in the original post that
 * inspired this class is certainly possible, but it is discouraged, as it
 * forces either the application or the service layer to be aware of
 * API-specific mechanisms as types. The preferred use is to construct Fetches
 * instances using a FetchStrategy object. Doing so will yield fully formed
 * instances without having to bother with any part of the MetaModel package.
 *
 * @author pierre
 *
 * @param <T>
 *            any class from the Domain package that extends BusinessKey
 */
public class Fetches<T extends BusinessKey> {
    
    private static final transient Logger LOG = Logger.getLogger(Fetches.class.getName());
    
    // List of SingularAttributes to eagerly fetch
    private final List<SingularAttribute<T, ?>> singularAttributes = new ArrayList<SingularAttribute<T, ?>>();
    // JoinTypes for SingularAttributes to eagerly fetch
    private final Map<SingularAttribute<T, ?>, JoinType> singularAttributesJoinTypes = new HashMap<SingularAttribute<T, ?>, JoinType>();

    // List of PluralAttributes to eagerly fetch
    private final List<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>> pluralAttributes = new ArrayList<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>>();
    // JoinTypes for PluralAttributes to eagerly fetch
    private final Map<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>, JoinType> pluralAttributesJoinTypes = new HashMap<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>, JoinType>();

    
    // The class object of the <T> parameter passed to the constructor
    private Class<?> clazz;

    /**
    * Standard no-arguments constructor. This is the one invoked when resolving
    * the <T> qualifier.
    *
    * @throws Exception
    */
    public Fetches() {
        Class<?> type = (Class<?>) ((ParameterizedType) getClass()
                .getGenericSuperclass()).getActualTypeArguments()[0];
        clazz = type;
    }

    /**
    * Constructor. Use this one if you do not know what <T> will be at coding
    * time, pass a Class object instead.
    *
    * @param clazz
    *            the Class object to construct this with
    * @throws Exception
    */
    public Fetches(Class<?> clazz) {
        this.clazz = clazz;
    }

    /**
    * Contructor. Use this one if <T> is not known at compile time, and you are
    * passing a FetchStrategyImpl to init the object
    *
    * @param clazz
    *            the Class object to construct this with
    * @param fetchStrategy
    *            the FetchStrategy to parse
    * @throws Exception
    */
    public Fetches(Class<?> clazz, FetchStrategyImpl fetchStrategy) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException{
        this.clazz = clazz;
        initFromFetchStrategyImpl(fetchStrategy);
    }

    /**
    * Contructor. This one will be used if <T> is known at compile time, and
    * you are passing a FetchStrategyImpl to init the object
    *
    * @param fetchStrategy
    *            the FetchStrategy to parse
    * @throws Exception
    */
    public Fetches(FetchStrategyImpl fetchStrategy) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
        Class<?> type = (Class<?>) ((ParameterizedType) getClass()
                .getGenericSuperclass()).getActualTypeArguments()[0];
        clazz = type;
        initFromFetchStrategyImpl(fetchStrategy);
    }

    /**
    * Contructor. This one will be used if <T> is known at compile time, and
    * you are passing a FetchStrategyJpaImpl to init the object
    *
    * @param fetchStrategy
    *            the FetchStrategy to parse
    * @throws Exception
    */
    public Fetches(FetchStrategyJpaImpl<T> fetchStrategy) throws ClassNotFoundException {
        Class<?> type = (Class<?>) ((ParameterizedType) getClass()
                .getGenericSuperclass()).getActualTypeArguments()[0];
        clazz = type;
        initFromFetchStrategyJpaImpl(fetchStrategy);
    }

    /**
    * Contructor. Use this one if <T> is not known at compile time, and you are
    * passing a FetchStrategyJpaImpl to init the object
    *
    * @param clazz
    *            the Class object to construct this with
    * @param fetchStrategy
    *            the FetchStrategyJpaImp to parse
    * @throws Exception
    */
    public Fetches(Class<?> clazz, FetchStrategyJpaImpl<T> fetchStrategy) throws ClassNotFoundException {
        this.clazz = clazz;
        initFromFetchStrategyJpaImpl(fetchStrategy);
    }

    /**
    * Method binding fetch attibutes to a Root object to be used by the
    * Criteria API.
    *
    * @param root
    *            the Root object to bind fetch attributes on
    * @param fetchMetamodel
    *            the Fetches instance in which all desired fetch attributes
    *            have been set
    */

    @SuppressWarnings("rawtypes")
    public static Root<? extends BusinessKey> bindFetchAttributes(final Root<? extends BusinessKey> root, final Fetches<?> fetchMetamodel) {
        if (fetchMetamodel != null) {
            // SingularAtributes
            List singularAttributes = fetchMetamodel.getSingularAttributes();
            for (int i = 0; i < singularAttributes.size(); i++) {
                SingularAttribute attribute = (SingularAttribute) singularAttributes.get(i);
                bindFetchSingularAttribute(root, fetchMetamodel, attribute);
             }

            // PluralAttributes
            List pluralAttributes = fetchMetamodel.getPluralAttributes();
            for (int i = 0; i < pluralAttributes.size(); i++) {
                PluralAttribute attribute = (PluralAttribute) pluralAttributes.get(i);
                bindFetchPluralAttribute(root, fetchMetamodel, attribute);
            }
        }
        return root;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    private static void bindFetchSingularAttribute(final Root<? extends BusinessKey> root, final Fetches<?> fetchMetamodel, SingularAttribute attribute) {
        LOG.log(Level.FINE, "Attempting to bind attribute {0}", attribute.getName());
        try {
            JoinType joinType = fetchMetamodel.getJoinType(attribute);
            if(joinType == null) {
                LOG.fine("No Join Type");
                root.fetch(attribute);
            } else {
                LOG.log(Level.FINE, "Join Type: {0}", joinType.toString());
                root.fetch(attribute, joinType);
            }
            LOG.fine("Bind successful");
        } catch(Exception e) {
            LOG.fine("Bind refused");
        }
    }
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
    private static void bindFetchPluralAttribute(final Root<? extends BusinessKey> root, final Fetches<?> fetchMetamodel, PluralAttribute attribute) {
        LOG.log(Level.FINE, "Attempting to bind attribute {0}", attribute.getName());
        try {
            JoinType joinType = fetchMetamodel.getJoinType(attribute);
            if(joinType == null) {
                LOG.fine("No Join Type");
                root.fetch(attribute);
            } else {
                LOG.log(Level.FINE, "Join Type: {0}", joinType.toString());
                root.fetch(attribute, joinType);
            }
            LOG.fine("Bind successful");
        } catch(Exception e) {
            LOG.fine("Bind refused");
        }
    }

    /**
    * Method translating a FetchStrategy.JoinType into a
    * javax.persistence.criteria.JoinType
    *
    * @param joinType
    *            the FetchStrategy JoinType to translate
    * @return the corresponding javax.persistence.criteria.JoinType
    */
    public static javax.persistence.criteria.JoinType getJoinType(
            FetchStrategyImpl.JoinType joinType) {
        if (joinType == null) {
            return null;
        }
        if (joinType.equals(FetchStrategyImpl.JoinType.LEFT)) {
            return javax.persistence.criteria.JoinType.LEFT;
        }
        if (joinType.equals(FetchStrategyImpl.JoinType.RIGHT)) {
            return javax.persistence.criteria.JoinType.RIGHT;
        }
        if (joinType.equals(FetchStrategyImpl.JoinType.INNER)) {
            return javax.persistence.criteria.JoinType.INNER;
        }
        return null;
    }

    /**
    * This method uses the FetchStrategyImpl passed to load the MetaModel class
    * corresponding to the <T> or Class object passed to the constructor, and
    * initializes all required attributes based on the FetchStrategy's data.
    *
    * @param fetchStrategy
    *            the FetchStrategyImpl instance to init from
    * @throws Exception
    */
    protected void initFromFetchStrategyImpl(FetchStrategyImpl fetchStrategy) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException {
        String className = clazz.getCanonicalName();
        LOG.log(Level.FINE, "Processing fetch strategy {0} for objects of type {1}", new Object[]{fetchStrategy.getName(), className});
        Class<?> metamodelClazz = Class.forName(className + "_", false, Thread.currentThread().getContextClassLoader());
        LOG.log(Level.FINE, "Building instance of Fetches<{0}> using FetchStrategy {1}", new Object[]{metamodelClazz.getSimpleName(), fetchStrategy.getName()});
        List<String> eagerlyLoadedFields = fetchStrategy.getEagerlyLoadedFieldsForClass(clazz);

        if (eagerlyLoadedFields != null && !eagerlyLoadedFields.isEmpty()) {
            for (String fieldName : eagerlyLoadedFields) {
                if(fieldName.equals(FetchStrategyImpl.ALL_FIELDS_MARKER)) {
                    processAllFieldsMarker(metamodelClazz, fetchStrategy);
                    // Meeting a * terminates the loop, of course.
                    break;
                } else {
                    processField(fieldName, metamodelClazz, fetchStrategy);
                }
            }
        } else {
            LOG.log(Level.FINE, "No eagerly fetched fields specified for {0} in FetchStrategy {1}", new Object[]{clazz.getSimpleName(), fetchStrategy.getName()});
        }
        LOG.fine("All done");
    }

    private void processAllFieldsMarker(Class<?> metamodelClazz, FetchStrategyImpl fetchStrategy) throws IllegalAccessException {
        LOG.fine("Adding all fields");
        Field[] fields = metamodelClazz.getFields();
        for(Field field : fields) {
            String name = field.getName();
            LOG.log(Level.FINE, "Processing Field {0}", name);
            Object attribute = field.get(metamodelClazz);
            JoinType joinType = getJoinType(fetchStrategy.getJoinType(clazz, name));
            if(joinType == null) {
                LOG.fine("No join type specified - defaulting to LEFT");
                joinType = JoinType.LEFT;
            } else {
                LOG.log(Level.FINE, "Join type: {0}", joinType.toString());
            }
            addFieldAttribute(attribute, joinType);
        }
    }

    private void processField(String fieldName, Class<?> metamodelClazz, FetchStrategyImpl fetchStrategy) throws NoSuchFieldException, IllegalAccessException {
        LOG.log(Level.FINE, "Processing Field {0}", fieldName);
        Field field = metamodelClazz.getField(fieldName);
        Object attribute = field.get(metamodelClazz);
        JoinType joinType = getJoinType(fetchStrategy.getJoinType(clazz, fieldName));
        addFieldAttribute(attribute, joinType);
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    private void addFieldAttribute(Object attribute, JoinType joinType) {
        if (attribute instanceof SingularAttribute) {
            LOG.fine("Adding as SingularAttribute");
            add((SingularAttribute) attribute, joinType);
        } else if (attribute instanceof PluralAttribute) {
            LOG.fine("Adding as PluralAttribute");
            add((PluralAttribute) attribute, joinType);
        }
    }

    /**
    * This method uses the FetchStrategyJpaImpl passed to load the MetaModel class
    * corresponding to the <T> or Class object passed to the constructor, and
    * initializes all required attributes based on the FetchStrategy's data.
    *
    * @param fetchStrategy
    * @throws Exception
    */
    protected void initFromFetchStrategyJpaImpl(FetchStrategyJpaImpl<T> fetchStrategy) throws ClassNotFoundException {
        String className = clazz.getCanonicalName();
        LOG.log(Level.FINE, "Processing instance of FetchStrategyJpaImpl for objects of type {0}", className);

        Class<?> metamodelClazz = Class.forName(className + "_", false, Thread.currentThread().getContextClassLoader());
        LOG.log(Level.FINE, "Building instance of Fetches<{0}>", metamodelClazz.getSimpleName());
        List<SingularAttribute<T, ?>> singularAttributesList = fetchStrategy.getSingularAttributes();
        singularAttributes.addAll(singularAttributesList);
        for(SingularAttribute<T, ?> attribute : singularAttributesList) {
            JoinType joinType = fetchStrategy.getJoinType(attribute);
            if(joinType != null) {
                singularAttributesJoinTypes.put(attribute, joinType);
            }
        }
        List<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>> pluralAttributesList = fetchStrategy.getPluralAttributes();
        pluralAttributes.addAll(pluralAttributesList);
        for(PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?> attribute : pluralAttributesList) {
            JoinType joinType = fetchStrategy.getJoinType(attribute);
            if(joinType != null) {
                pluralAttributesJoinTypes.put(attribute, joinType);
            }
        }
    }

    /**
    * Getter
    *
    * @return
    */
    public Class<?> getType() {
        return clazz;
    }
    /**
    * Adds a SingularAttributes with the default JoinType
    *
    * @param singularAttribute
    *            the attribute to add
    * @return this
    */
    public Fetches<T> add(SingularAttribute<T, ?> singularAttribute) {
        return add(singularAttribute, null);
    }

    /**
    * Adds a SingularAttributes with a specific JoinType
    *
    * @param singularAttribute
    *            the attribute to add
    * @param joinType
    *            the desired JoinType
    * @return this
    */
    public Fetches<T> add(SingularAttribute<T, ?> singularAttribute,
            JoinType joinType) {
        singularAttributes.add(singularAttribute);
        if(joinType != null) {
            singularAttributesJoinTypes.put(singularAttribute, joinType);
        }
        return this;
    }

    /**
    * Adds a PluralAttribute with the default JoinType
    *
    * @param pluralAttribute
    *            the attribute to add
    * @return this
    */
    public Fetches<T> add(
            PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?> pluralAttribute) {
        return add(pluralAttribute, null);
    }

    /**
    * Adds a PluralAttribute with a specific JoinType
    *
    * @param pluralAttribute
    * @param joinType
    *            the desired JoinType
    * @return
    */
    public Fetches<T> add(
            PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?> pluralAttribute,
            JoinType joinType) {
        pluralAttributes.add(pluralAttribute);
        if(joinType != null) {
            pluralAttributesJoinTypes.put(pluralAttribute, joinType);
        }
        return this;
    }

    /**
    * Getter.
    *
    * @return the raw list
    */
    public List<SingularAttribute<T, ?>> getSingularAttributes() {
        return getSingularAttributes(false);
    }

    /**
    * Getter. Returns either the raw list, or a read-only version of it
    *
    * @param unmodifiable
    *            specifies if the list has to be made read-only
    * @return if true, a read-only version of the list is returned, if false,
    *         the raw list is returned
    */
    public List<SingularAttribute<T, ?>> getSingularAttributes(
            boolean unmodifiable) {
        if (unmodifiable) {
            return Collections.unmodifiableList(singularAttributes);
        } else {
            return singularAttributes;
        }
    }

    /**
    * Getter.
    */
    public JoinType getJoinType(SingularAttribute<T, ?> attribute) {
        return singularAttributesJoinTypes.get(attribute);
    }

    /**
     * Getter.
     */
     public JoinType getJoinType(PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?> attribute) {
         return pluralAttributesJoinTypes.get(attribute);
     }

    /**
    * Getter.
    *
    * @return the raw list
    */
    public List<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>> getPluralAttributes() {
        return getPluralAttributes(false);
    }

    /**
    * Getter. Returns either the raw list, or a read-only version of it
    *
    * @param unmodifiable
    *            specifies if the list has to be made read-only
    * @return if true, a read-only version of the list is returned, if false,
    *         the raw list is returned
    */
    public List<PluralAttribute<T, ? extends Collection<? extends BusinessKey>, ?>> getPluralAttributes(
            boolean unmodifiable) {
        if (unmodifiable) {
            return Collections.unmodifiableList(pluralAttributes);
        } else {
            return pluralAttributes;
        }
    }

}
